HOST: http://api.commonsenses.com/


--- CommonSenses API v1 (draft.5) ---
---
CommonSenses provides tools to create an internet-of-things (IoT) application.  It takes care of all
communications with sensor devices and provides their data in a common format to application
developers.

The quickest way to see working code is to go to the Sandbox Server section below, copy the Python
code and run it.

CommonSenses associates a sensor device to a user.  It collects and stores 
 data generated by the sensor in a common format based on the sensor's metric types (e.g. blood pressure,
weight, etc).  Data is stored in the user's account so that your application may later
access it.  Numerous sensor sources are supported and we regularly add new ones.  The currently supported sensor sources
are defined in the Collector resources section below.  Please
ask [support@commonsenses.com] (mailto:support@commonsenses.com) if you do not see a device your users want to utilize.

An authorized application may obtain the latest metrics or a history of them. For example an 
application may request the number of steps a user has taken so far today or 
it may request the number of steps a user took during the month of November.

CommonSenses uses OAUTH 2.0 to control access to a user's data.  All requests sent to a CommonSenses service point includes the Authorization header
require a valid access token.

You may obtain your application (sometimes referred to as 'consumer' or 'client') id and password 
here:  [dev.commonsenses.com](http://dev.commonsenses.com)
You will need to login with your Facebook credentials in order to create and
manage your CommonSenses application ids and passwords.

CommonSenses supports JSON output which must be specified via the
Accept http header in a request. 

The resources in CommonSenses are user, collector and metrics.  Each is described in
detail in later sections.

A user is a uniquely identified set to which collectors and metrics may be associated.

A collector is a source of metrics.  Generally this is a sensor, although an application
may generate metrics as well.

A metric is any physical world data associated with a user. 

A metric type defines the type of physical world data that a metric represents 
(e.g. steps, heart rate, etc). When storing a metric the format and data units of the data 
is defined by a named profile. When retrieving a metric the profile of the data will be the 
profile used when it was stored. 

A metric collection is more than one metric.

In short, you will read and write metrics and metric collections and each metric will have 
a particular metric type and use a particular profile defining its data format and units.

Errors are reported in two manners. First is an HTTP status code.

A status code in the 200 range indicates that the request was successful and that the 
response body may contain the results from the request. The exception being a 201 response 
from a POST request. In this case a url for the new resource will be returned in a 
Location header in the response.

A status code in the 400 range indicates an error related to the client request. In some 
cases this fixable by the user or the client application. A status code in the 500 range 
indicates an error related to the operation of the CommonSenses server. This is not fixable 
by the user or the client application. The user should be told that the operation could not 
completed and to try again later.

The second reporting mechanism is an error message in the response body. For 40x and 
50x errors, the response body will contain a json object with the following format:

Example:

{
  "error":"keyword",
  "error_description":"a descriptive error of what went wrong"
}

The keywords match the error keywords to be found in the individual operation documentation.

---
--
Authorization
All requests for resources are controlled by an access token. The easiest access token for an application to request is one based on its own credentials. These credentials are the application id and application secret generated when you registered your application on the [dev.commonsenses.com](http://dev.commonsenses.com) website.

This application authentication used to get this application access token is based on the JSON Web Token ( JWT ). The JWT is comprised of 3 sections: a header, a claim, and a signature. Each section is a base64 url encoding of some string. The combination of these 3 sections is called the assertion.

### Header
The header MUST be based on this JSON: {"alg":"HS256","typ":"JWT"}. HS256 stands for HMAC-SHA256. This is the only type of encryption and hashing supported by the CommonSenses server for this token request. This is string is then base64 url encoded ( we'll call this the encoded_header ).

### Claim
The claim MUST follow this format ( all fields are required ): {"iss":"[application_id]","prn":"[application_id]","aud":"https            theLogger.debug( "not a steps metric. skipping...")
://api.commonsenses.com/oauth/token","exp":[expiration_time]} .
Where [application_id] is the application id generated for your application on the [dev.commonsenses.com](http://dev.commonsenses.com) website. 
And [expiration_time] is the time, in milliseconds from Jan 01, 1970, of when CommonSenses should reject your request as being too old. This is prevent replay attacks. Due to the possibility of timestamp mismatches between machines, this expiration time isn't strictly enforced, there is 2 minute window past the stated expiration time where we still treat it as valid.

This string is also base64 url encoded ( we'll call this the encoded_claim ).

### Signature
From the encoded_header and encoded_claim, you need to generate a signature.
1. combine encoded_header and encoded_claim into a single string, using a "." delimiter: encoded_header.encoded_claim
2. Using an HMAC-SHA256 encryption algorithm and using the application secret as the encryption key, generate a signature based on the combined string from 1.
3. base64 url encode this signature ( we'll call this the encoded_signature )

### Assertion
The assertion is the concatentation of the 3 encoded strings using a "." delimiter:
encoded_header.encoded_claim.encoded_signature

### Code Samples
Ruby: 

Uses json gem.

	require "base64"
	require "openssl"
	require "rubygems"
	require "json"

	application_id="my-application-id"
	application_secret="my-secret"

    # expire two minutes from now
	expire_time=Time.now.to_i*1000+2*60*1000

    # create the header
	header={"typ"=>"JWT","alg"=>"HS256"}
	header_str=JSON.dump(header)

    # create the claim
	claim={"iss"=>application_id,
		   "prn"=>application_id,
		   "aud"=>"https://api.commonsenses.com/oauth/token",
		   "exp"=>expire_time}
	claim_str=JSON.dump(claim)

    # create the encoded input
	encoded_header=Base64.urlsafe_encode64(header_str)
	encoded_claim=Base64.urlsafe_encode64(claim_str)
	segments=[]
	segments << encoded_header
	segments << encoded_claim
	secure_input=segments.join(".")

    # create the signature and remove the last base64 encoded character ( usually a "=" symbol )
	signature=OpenSSL::HMAC.digest(OpenSSL::Digest::Digest.new("sha256"),application_secret,secure_input)
	encoded_signature=Base64.urlsafe_encode64(signature)[0..-2]

    # concatenate the assertion
	segments << encoded_signature
	assertion=segments.join(".")


Python:

	import base64
	import hashlib
	import hmac
	import json
	import time
	import math

	application_id="my-application-id"
	application_secret="my-secret"

    # expire two minutes from now
	expire_time=math.trunc(time.time()*1000)+2*60*1000

    # create the header
	header={"typ":"JWT","alg":"HS256"}

    # create the claim
	claim={"iss":application_id,
		   "prn":application_id,
		   "aud":"https://api.commonsenses.com/oauth/token",
		   "exp":expire_time}

    # create the encoded input
	encoded_header=base64.urlsafe_b64encode(json.dumps(header)).replace("=","")
	encoded_claim=base64.urlsafe_b64encode(json.dumps(claim)).replace("=","")
	segments=[]
	segments.append(encoded_header)
	segments.append(encoded_claim)
	signing_input='.'.join(segments)

    # create the signature
	signature=hmac.new(application_secret,signing_input,hashlib.sha256).digest()
	encoded_signature=base64.urlsafe_b64encode(signature).replace("=","")

    # concatenate the assertion
	segments.append(encoded_signature)
	assertion='.'.join(segments)

PHP:

	function get_CS_application_token_JWT_assertion()
	{
	  $applicationId = APP_ID;
	  $applicationSecret = APP_SECRET;

	  $url = HOSTNAME . '/oauth/token';

	  // expire two minutes from now                                                                         
	  $expireTime = time() * 1000 + 2*60*1000;

	  // create the header                                                                                   
	  $header = array('typ' => 'JWT', 'alg' => 'HS256');

	  // create the claim                                                                                    
	  $claim = array('iss' => $applicationId,
	                 'prn' => $applicationId,
	                 'aud' => $url,
	                 'exp' => $expireTime);

	  // create the signature                                                                                
	  $segments = array();
	  $segments[] = urlsafeB64Encode(json_encode($header));
	  $segments[] = urlsafeB64Encode(json_encode($claim));
	  $signing_input = implode('.', $segments);
	  $signature = hash_hmac('sha256', $signing_input, $applicationSecret, true);
	  $segments[] = urlsafeB64Encode($signature);

	  return implode('.', $segments);
	}

	function urlsafeB64Encode($input)
	{
	  return str_replace('=', '', strtr(base64_encode($input), '+/', '-_'));
	}


Java:

Uses [json.org JSON library](http://json.org/java/)  and  Base64 from [Apache Commons Codec](http://commons.apache.org/proper/commons-codec/):

	import org.json.JSONObject;
	import javax.crypto.Mac;
	import javax.crypto.spec.SecretKeySpec;
	import org.apache.commons.codec.binary.Base64

	final String applicationSecret = "my-secret";
	final String applicationId = "my-application-id";
    /* create the header */
	final JSONObject header = new JSONObject();
	header.put("typ", "JWT");
	header.put("alg", "HS256");

    /* create the claim */
	final JSONObject claim = new JSONObject();
	claim.put("iss", applicationId);
	claim.put("aud", "https://api.commonsenses.com/oauth/token");
	claim.put("prn",applicationId);
    /* expires in 2 minutes */
	claim.put("exp",System.currentTimeMillis()+2*60*1000 );
    
	/* create the encoded input */
	final String encodedHeader = Base64.encodeBase64URLSafeString( header.toString().getBytes() );
	final String encodedClaim = Base64.encodeBase64URLSafeString( claim.toString().getBytes());
	final String encodedSecureInput = encodedHeader+"."+encodedClaim;

    /* generate the signature */
	final Mac hmac = Mac.getInstance("HmacSHA256");
	final SecretKeySpec signingKey = new SecretKeySpec(applicationSecret.getBytes(), "HmacSHA256");
	hmac.init(signingKey);
	hmac.update(encodedSecureInput.getBytes());
	final byte[] signatureBytes = hmac.doFinal();
	final String encodedSignature = Base64.encodeBase64URLSafeString(signatureBytes);

    /* contatentate the assertion */
	final String encodedSignedAssertion = encodedSecureInput+"."+encodedSignature;
        

### Errors
Errors are returned with a 400 status code and a JSON body of the format

   { "error":"invalid_client",
     "error_description":"`<some string>`" }

<table border=1>
<tr><th>Error Condition</th><th>error_description</th><th>Remediation</th></tr>
<tr><td>iss value is not valid</td><td>invalid_client_id : there is no client with the supplied id</td><td>verify that the iss matches your application id</td></tr>
<tr><td>iss and prn values do not match</td><td>client_id_mismatch : the iss and prn values do not match</td><td>verify that the iss and prn match your application id</td></tr>
<tr><td>iss value has been deactivated</td><td>client_deactivated : the supplied iss value has been deactivated</td><td>contact support at support@elbrys.com</td></tr>
<tr><td>exp value is too old</td><td>assertion_expired : the supplied exp value is too far in the past</td><td>exp value was more than two minutes in the past by the time it was recieved. verify your system time is accurate or increase the expiration time</td></tr>
<tr><td>server could not validate the signature</td><td>signature_invalid : the server was unable to verify the signature</td><td>verify that the application secret used to sign is correct and/or that bas64url encoded was used</td></tr>
<tr><td>aud value was incorrect</td><td>audience_not_valid : the aud value was invalid for the target server</td><td>verify that aud is https://api.commonsenses.com/oauth/token</td></tr>
<tr><td>claim was missing one or more required fields</td><td>claim_invalid : the claim was missing the `<field name>` field</td><td>verify that iss, prn, aud, and exp are present in the claim</td></tr>
</table>

### Special Privileges
With this access token, a client application gets some special privileges within CommonSenseses.

* create User records
* full access to all metric types for all Users associated with your application

--
Get a new access token.

Parameters:

* __grant_type__: Required. MUST be urn:ietf:params:oauth:grant-type:jwt-bearer
* __assertion__: Required. The encoded assertion string

Response:

* __access_token__: a hexadecimal string representing the access token
* __scope__: "all" (currently "all" is the only scope returned)
* __token_type__: "application_access" (currently "application_access" is the only token_type returned)
* __expires_in__: the number of seconds in which this token will expire (e.g. 86400 = 1 day) 

GET /oauth/token?grant_type={grant_type}&assertion={assertion}
> Accept: application/json
< 200
< Content-Type: application/json
{ "access_token":"HEXDECSTRING",
  "scope":"all",
  "token_type":"application_access",
  "expires_in",86400 }
+++++
< 400
< Content-Type: application/json
{ "error":"invalid_client",
  "error_description":"claim_invalid : the claim was missing the iss field" }

--
User Resources
A user is the data element to which collectors and metrics are associated.

### JSON User Definition:
* __id__: Required for PUT. N/A for POST. The CommonSenses user id of the user.
* __name__: Optional for POST. A human-readable name. Will be used to personalize CommonSenses web resources and by customer support
* __timeZone__: Optional for POST. A valid timezone name from [IANA Timezone Database](http://www.iana.org/time-zones). Used with some 3rd party vendors to estabilish correct timestamps on data. If not provided GMT is assumed for the user.
* __identity.providedId__: Required for POST. A unique identifier from the creating application's system for this user.

### NOTE
* After a POST the user id will be returned in the 'Location' header of the HTTP response.
--

Create a user. Users created by an application are only visible to application that created them. This POST operation is considered idempotent. If the same identity.providerId value is used, then the application can rediscover the commonsenses id of that user. No updates will be done via this POST operation.

POST /user
> Authorization: bearer {access_token}
> Content-Type: application/vnd.commonsenses.v1+json
{ "identity":[{ "providerId":"aef093-a92893-ef89abc"}],
  "name":"John Q. Public",
  "timeZone":"America/New_York"}
< 201
< Location: /user/{userId}
--
Update a user. Only name and timeZone will be updated.

PUT /user/{userId}
> Authorization: bearer {access_token}
> Content-Type: application/vnd.commonsenses.v1+json
{ "id":"123123",
  "name":"John Q. Public",
  "timeZone":"America/Chicago"}
< 204

--
Metric Resources
A Metric is a collection of digital representations of some measurable 
event in the physical world. Each Metric is defined by a type, a profile, 
start times, end times, and metadata.

Data represents a single sample of that measurable event taken either at a 
single point in time or over some time range.

A list of metrics is called a Metric Collection.
### JSON Metric Definition:
* __ver__: Required for POST & PUT.  The version of the format used in the JSON.  Currently always 1.
* __profileUnits__:  Required for POST & PUT.  The units of the returned metrics.  g = Gravities, {activity} = an activty type, mg/dL = Milligrams per Decaliter, kPa = kilopascals, mm[Hg] = millimeters of mecury, kg/m2 = kilograms per meter^2, Cal = kilocalories, km = kilometers, cm = centimeters, deg = degrees, m = meters, [MET] = metabolic equivalence unit, {beat}/min = beats per minute, km/h = kilometers per hour, {step} = steps, kg = kilograms, % = percent, [degF] = degrees Fahrenheit, Cel = degrees Celsius, [lb_avg] = average weigh in lbs, lb = pounds, {intensityLevel} = intensity level 
* __profileName__:  Required for POST & PUT.  The values in the 'Value' field of the 'Data' field has a specific syntax for the values.  This field, profileName, defines that format. distanceTraveled = {distance traveled in km}, caloriesBurned = {calories burned}, speed = {speed in km/h}, location = [{latitude}, {longitude}, {elevation in meters}], met = {metablic equivalent task}, accelerometer = [{x acceleration in g}, {y acceleration in g}, {z acceleration in g}], steps = {steps}, activityType = {activity}, bloodPressure = [{systolic},{diastolic},{mean arterial pressure}], pulseRate = {pulse rate in {beat}/min}, weight = {weight in lb, [lb_avg], kg}, height = {height in cm},
bmi = {body mass index}, intensityLevel = [{intensityLevel},{intensityLevel},{intensityLevel},{intensityLevel},{intensityLevel}],
bloodGlucose = {glucose level}, bloodOxygen = { % }, bodyTemperature = { [degF] or Cel }, environmentalTemperature = { [degF] or Cel }
* __metricType__:  Required for POST & PUT.  The type of metric.  The enumeration for valid values is the same as __types__ in the GET request.
* __collector__:  Optional for POST (defaults to application identifier that is doing the POST).  A definition of the collector (sensor or application) that generated the metric.
    *    __href__:  A Universal Resource Identifier (URI) defining the collector.  The numeric value in the URI may be used in Collector methods of this RESTful API.
    *    __rel__:  Indicates that this URI is NOT a Universal Resource Locator (URL) and cannot be followed.
* __metricId__:  Not used for POST. Required for PUT. Always present in GET (if present then it will add data to the existing metic).  A unique identifier the metric.
* __profileAccumulator__:  Requried for PUT, Optional for POST (defaults to native).  A metric's value often represents a sample period.  Since multiple values may be gathered during a sample period and a metric represents it as a single value it is important to understand how the values during the sample period were combined to generate the single value.  native = no accumulation occurred,  sum = the values of the sample period were added together,  avg = the values of the sample period were added together and divided by the number of samples.
* __link__:  Not used in POST or PUT. Present in GET and represent the url to directly access this metric.
* __startTime__: Never in POST.  The value of the startTime field of the first Data sample.
* __endTime__:  Never in POST.  The value of the endTime field of the last Data sample.
* __operator__:  Optional for POST (defaults to user).  Describes who took the metric readings.
    *    __href__:  A Universal Resource Identifier (URI) defining the user that took the reading.  The numeric value in the URI may be used in User methods of this RESTful API.
    *    __rel__:  Indicates that this URI is NOT a Universal Resource Locator (URL) and cannot be followed.
    *    __professional__:  Optional for POST (defaults to false).  Boolean indicating whether the operator was a trained medical professional or not.
*    __data__:  Optional for POST (a POST without data creates a __metricId__ that can be used with PUTs) A list of data values of the metric.
    *    __startTime__:  The start time of the sampling of this data value.
    *    __endTime__:  The end time of the sampling of this data value.
    *    __value__:  A list containing the value in the __profileName__ format, in the __profileUnits__ units, using the __profileAccumulator__ to combine the values during the sampling period.  It is a list in case a single value has multiple pieces of information (blood pressure, location, etc).
*    __metadata__:  Optional for POST. an arbitrary set of name/value pairs that allow an application to provide additional, application specific, information with a Metric. Names can be arbitrary and may contain an optional domain prefix to help distinguish the metaData written by different applications.
--
Create new metric.  This is used if your application is acting as a collector/sensor.  Otherwise this is rarely used by an application.

POST /user/{userId}/metric
> Authorization: bearer {access_token}
> Content-Type: application/vnd.commonsenses.v1+json
{
"data" : [ {
            "endTime" : "2013-04-01T11:45:24.127-04:00",
            "startTime" : "2013-04-01T11:45:24.126-04:00",
            "value" : [ "1305" ]
           } ],
"metaData" : [ {
                 "com_Elbrys_MetadataExample1" : "34"
               },
               {
                "org_Example_MetaDataExample2" : "Example Metadata"
                } ],
"metricType" : "steps",
"profileAccumulator" : "sum",
"profileName" : "steps",
"profileUnits" : "{step}",
"ver" : "1"
}
< 201
< Location: /metric/1043487174283814390993

Update existing metric.  Similar to POST this is used if your application is acting as a collector/sensor.

PUT /metric/{metricId}
> Authorization: bearer {access_token}
> Content-Type: application/vnd.commonsenses.v1+json
{
    "ver": "1",
    "metricType": "steps",
    "profileName": "steps",
    "data": [
        {
            "endTime": "2012-09-20T03:59:59.999Z",
            "value": ["1500"],
            "startTime": "2012-09-19T04:00:00.000Z"
        }
    ]
}
< 202
< Content-Type: application/vnd.commonsenses.v1+json

Get Details for an existing metric

GET /metric/{metricId}
> Authorization: bearer {access_token}
> Accept: application/vnd.commonsenses.v1+json
< 200
< Content-Type: application/vnd.commonsenses.v1+json
{
            "ver": "1",
            "profileUnits": "{step}",
            "collector": {
                "href": "/collector/1058653470622537068986",
                "rel": "nofollow"
            },
            "metricId": "1041316279648494430789",
            "metricType": "steps",
            "profileAccumulator": "sum",
            "link": [],
            "startTime": "2013-04-01T15:45:24.126Z",
            "profileName": "steps",
            "operator": {
                "href": "/user/1016478538088269831140",
                "rel": "nofollow"
            },
            "professional": false,
            "endTime": "2013-04-01T15:45:24.127Z",
            "data": [
                {
                    "endTime": "2013-04-01T15:45:24.127Z",
                    "value": [
                        "1305"
                    ],
                    "startTime": "2013-04-01T15:45:24.126Z"
                }
            ],
            "metaData": [
                {
                    "com_Elbrys_MetadataExample1": "34"
                },
                {
                    "org_Example_MetaDataExample2": "Example+Metadata"
                }
            ]
        }
}

### JSON Metric Collection Definition:
* __totalCount__: Required for POST.  The total number of "metric" elements.
* __metric__: an array of the "metric" elments

--
Get metric collection.

Parameters:

* __max_returns__:  Optional (default: 10).  When a query generates a large number of results they will not all be returned but will instead be returned in pages.  This parameter defines a number of results per page (number of pages = total in result set / max_returns)
* __start_index__:  Optional, required if max_returns defined (default: 0).  Defines the page number to return.
* __types__:  Optional (default: all).  Defines a comma delimited list of metric types to be returned.  Valid values: *accelerometer,activityType,bloodGlucose,bloodOxygen,bloodPressure,bmi,bodyTemperature,caloriesBurned,distanceTraveled,
environmentalTemperature,height,intensityLevel,location,met,pulseRate,speed,steps,weight,*
* __start_time__:  Optional, required if end_time defined.  When specified only metrics with start times that are equal to or after this time are returned.  Format is: YYYY-MM-DDTHH:mm:ss.SSS-XX:yy.  YYYY = year, MM = 2 digit month (01-12), DD = 2 digit day of month (01-31), T = T, HH = 2 digit hours (01-23), mm = 2 digit minutes (00-59), ss = 2 digit seconds (00-59), SSS = 3 digit milliseconds (000-999) optional, XX = 2 digit hour offset from GMT for timezone (00-23), yy = 2 digit minute offset from GMT for timezone (00-59)
* __end_time__:  Optional, required if start_time defined.  When specified only metrics with end times that are equal to or before this time are returned.  Format is: YYYY-MM-DDTHH:mm:ss.SSS-XX:yy
* __order__:  Optional (default: ascending).  Specifies the ordering of the metrics results.  Valid values:  *asc, desc*
* __gmt_offset__:  Optional (default: GMT).  Number of minutes offset from GMT for the user.
GET /user/{commonSensesId}/metric-collection?start_index={integer}&max_returns={integer}&types={type1,type2}&start_time={YYYY-MM-DDTHH:mm:ss.SSS-XX:yy}&end_time={YYYY-MM-DDTHH:mm:ss.SSS-XX:yy}&order={asc/desc}&gmt_offset={integer}
> Authorization: bearer {access_token}
> Accept: application/vnd.commonsenses.v1+json
< 200
< Content-Type: application/vnd.commonsenses.v1+json
{
    "totalCount": 1,
    "metric": [
        {
            "ver": "1",
            "profileUnits": "{step}",
            "collector": {
                "href": "/collector/1058653470622537068986",
                "rel": "nofollow"
            },
            "metricId": "1041316279648494430789",
            "metricType": "steps",
            "profileAccumulator": "sum",
            "link": [],
            "startTime": "2013-04-01T15:45:24.126Z",
            "profileName": "steps",
            "operator": {
                "href": "/user/1016478538088269831140",
                "rel": "nofollow"
            },
            "professional": false,
            "endTime": "2013-04-01T15:45:24.127Z",
            "data": [
                {
                    "endTime": "2013-04-01T15:45:24.127Z",
                    "value": [
                        "1305"
                    ],
                    "startTime": "2013-04-01T15:45:24.126Z"
                }
            ],
            "metaData": [
                {
                    "com_Elbrys_MetadataExample1": "34"
                },
                {
                    "org_Example_MetaDataExample2": "Example+Metadata"
                }
            ]
        }
    ],
    "error": []
}




--
Collector Resources
A Collector resource is able to post new metrics to a user.  Typically a collector is a sensor.  A collector may be direct or indirect.
An direct sensor is one that communicates its metrics from the sensor directly to CommonSenses.  An 
indirect sensor is one that communicates its metrics to a 3rd party web service (FitBit, BodyMedia, etc) and CommonSenses obtains the metrics
from this 3rd party web service.

All of the currently supported direct sensors require the CommonSenses Gateway Application to be installed onto a device that 
has the required personal area network (PAN) radio support (typically Bluetooth).  CommonSenses Gateway Application
is currently supported on Android 4.1 mobile phones.  Elbrys can work with a customer to port the Gateway Application to other
mobile phones or to residential gateway devices, please just contact [support@commonsenses.com](mailto:support@commonsenses.com).

The CommonSenses Gateway Application is NOT required to support indirect sensors.

A collector must be associated with a user in order for it to post metrics to that user.  An indirect sensor may be associated with a user
utilizing the POST method below.  The ability to associate a direct sensor to a user is coming soon, please 
contact [support@commonsenses.com](mailto:support@commonsenses.com) to learn when this is available.

Because the POST method requires some end-user interaction, we have created a javascript library to make this easier.  This javascript library
is called SensorManager and it provides a pop-up window that allows a user to manage their indirect sensors (and soon to manage their direct 
sensors).  Within the SensorManager the user sees the sensors they have associated, which are available to associate and allows them to associate
or disassociate sensors.

The currently supported and tested direct and indirect sensors are shown here.  Please contact  [support@commonsenses.com](mailto:support@commonsenses.com) if
you do not see a sensor you wish to support.  Remember, at this time only indirect sensors may be associated to a user, but direct are coming soon.

### Blood Pressure
* ForaCare D40b (direct: Bluetooth)
* A&D Medical (direct: Bluetooth, ANT)
* Omron Healthcare (direct: Bluetooth)
* Withings BP-800 (indirect)

### Temperature
* ForaCare IR20b (direct: Bluetooth)

### Heart Rate
* Timex Flex Tech  (direct: ANT)
* Wahoo Fitness HeartWear (direct: ANT)
* Wahoo Fitness BlueHR (direct: Bluetooth Smart)

### Steps, Distance traveled, Calories burned
* A&D Medical XL-25ANT (direct: ANT)
* BodyMedia Fit BW Armband (indirect)
* FitBit Classic, Ultra, One, Zip (indirect)
* Timex Foot Pod (direct: ANT)
* Wahoo Fitness Foot Pod (direct: ANT)
* Garmin Foot Pod (direct: ANT)
* FitBug FB912 (indirect)
* FitLinxx Actiped, Pebble (indirect)
* Runkeeper (indirect, no steps)

### Blood Oxygen
* Nonin Onyx II 9560 (direct: Bluetooth)

### Blood Glucose
* ForaCare D40b (direct: Bluetooth)
* Entra Health Systems myglucohealth (direct: Bluetooth)

### Weight, Body Composition
* A&D Medical UC-321PBT-G, UC-324ANT (direct: Bluetooth, ANT)
* FitSense ActiScale Pro (indirect)
* FitBit Aria (indirect)
* Withings (indirect)
* Omron HBF-206IT(Z) (direct:Bluetooth)


### JSON Collector Definition:
* __ver__:  Required for POST.  The version of the format used for this JSON definition.  Currently only version 1 is supported.
* __profile__: Only for GET.  Not currently used.
* __selected__:  Only for GET.  Boolean indicating whether the user has selected this collector to be used.
* __dateOfLastReading__:  Only for GET.  Indicates the last date that a new metric was received from the collector.
* __collectorId__:  Only for GET.  A unique identifier created by CommonSenses for the collector.
* __connectionType__:  Required for POST.  How does CommonSenses communicate with the collector:  __internal__ = a direct sensor that is part of a larger device and is accessed via internal APIs (e.g. cell phone accelerometer or gps ), __algorithm__ = a software algorithm run by your application used to calculate metrics, __ant+__ = a direct sensor that uses the ANT+ communication protocol, __continua_bt__ = a direct sensor that uses BlueTooth radio and the Continua communciation protocol, __continua_usb__ = a direct sensor that uses a USB connection and the Continua communication protocol, __serial_bt__ = a direct sensor that uses BlueTooth radio and serial protocol, and __webservice__ = an indirect sensor that uses a 3rd party web service.
*    __deviceManufacturer__:  Required for __connectionType__ = webservice.  Defines the 3rd party web service to connect CommonSenses to: *fitbit, fitlinxx, fitbug, bodymedia, runkeeper, withings*
*    __connection__:  Only for GET.  Indicates the status of the webservice connection.
*         __tokenGood__:  Only for GET.    Because most webservice connections rely on OAUTH and access tokens the access tokens can sometimes become invalid.  If true then the token is fine, otherwise the user should reauthorize CommonSenses.
*    __active__:  Only for GET.  Boolean indicating whether this sensor is 'active'.
*    __manufacturerProductName__:  Only for GET.  Provides a specific model identifier in case the manufacturer supports multiple sensors.
*    __name__:   Optional.  A human-readable name of the collector. In the case of webservice connectionType vendors, this will be the device serial number, if available.

### JSON Collector Collection Definition:
* __totalCount__: Only for GET.  The total number of "collector" elements.
* __collector__: An array of "collector" elements.

--
Get collectors associated with user.

Parameters:

* __active__:  Optional (default: false).  If set to true, then only return collectors that are marked as active.

GET /user/{userId}/collector-collection
> Authorization: bearer {access_token}
> Accept: application/vnd.commonsenses.v1+json
< 200
< Content-Type: application/vnd.commonsenses.v1+json
{
    "totalCount": 3,
    "collector": [
        {
            "profile": [],
            "selected": false,
            "dateOfLastReading": "2013-03-01T23:47:24.335Z",
            "collectorId": "105414271826408831692",
            "connectionType": "webservice",
            "deviceManufacturer": "fitlinxx",
            "connection": {
                "tokenGood": true
            },
            "active": true,
            "manufacturerProductName": "Pebble"
        },
        {
            "profile": [],
            "ver": "1",
            "name": "1001875581218806767393-101602159023687610599",
            "selected": false,
            "dateOfLastReading": "2013-03-01T23:47:21.961Z",
            "collectorId": "105653845562935913077",
            "connectionType": "internal",
            "active": true
        },
        {
            "profile": [],
            "ver": "1",
            "selected": false,
            "dateOfLastReading": "2013-03-01T23:47:24.340Z",
            "collectorId": "1052454397713684282226",
            "connectionType": "internal",
            "deviceManufacturer": "fitlinxx",
            "active": true
        }
    ]
}

Associate a new collector to a user.  If SensorManager is used then you do not
need to use this POST directly, SensorManager javascript will do all this for you.  
Currently only support for creating collectors of the ‘webservice’ connectionType.  
When creating a webservice collector for the user, this needs to be 
done in an environment that can support an HTTP redirect ( status code 302 ). This is required as the user needs to 
be directed to the vendor’s website to authorize CommonSenses to access data from his/her device. This is the same 
environment that is required for the CommonSenses OAuth process.  In order for CommonSenses to report back to the 
application that the Authorization has successfully completed, the application needs to pass along a request_uri 
query parameter with the initial POST. CommonSenses will send a 302 redirect to this url once the authorization 
cycle has been completed. This request_uri needs to be a fully qualified 
url ( e.g., http://www.example.com/device-auth-complete ).  Once control has been handed back to the application 
via the request_uri, the application can get GET the user’s collectors (GET User Collectors) and look for 
the one that matches the expected vendor.
POST /user/{userId}/collector?request_uri={requestUri}
> Authorization: bearer {access_token}
> Content-Type: application/vnd.commonsenses.v1+json
{
    "ver": "1",
    "connectionType": "webservice",
    "deviceManufacturer": "fitlinxx"
}
< 201
< Location: /collector/364757687932282765869232361

Get details for an existing collector.

GET /collector/{collectorId}
> Authorization: bearer {access_token}
> Accept: application/vnd.commonsenses.v1+json
< 200 
{  
    "active":true,
    "collectorId":"123",
    "connection"{"tokenGood":true},
    "connectionType":"webservice",
    "dateOfLastReading":"2015-04-17T05:59:59.999Z",
    "deviceManufacturer":"fitbit",
    "manufacturerProductName":"FitBit",
    "name":"abc",
    "profile":[],
    "selected":false,
    "ver":"1"
}

--
SensorManager GUI
The SensorManager allows a developer to quickly provide their user's 
the ability to associate and disassociate sensors.  

The SensorManager is a javascript library that causes a pop-up window 
to appear where a user may see currently supported sensors, see which 
sensors they have associated, see the current state of the sensors and
associate new sensors.

The sensor manager is a standalone package with dependencies on jQuery and the commonsenses-sdk.js file.
The developer will need to add the following lines in the script tag of the html page that contains a link to show the sensor manager.
    
    <script type="text/javascript" src="https://api.commonsenses.com/commonsenses-sdk/js/jquery/commonsenses-jquery.min.js"></script>
    <script type="text/javascript" src="https://api.commonsenses.com/commonsenses-sdk/js/commonsenses-sdk.js"></script>

## If you have both application id/secret and token then initialize CommonSenses. 


    CommonSenses.init(csApplicationId, csApplicationSecret, scopes, baseUrl, accessToken, 
                        function()
                            {
                            /* success callback */
                                // set requirements
                                // show sensor manager
                            }, 
                        function()
                            {
                            /* failure callback */
                                // handle failure
                            });

where

* csApplicationId: CommonSenses application id
* csApplicationSecret: CommonSenses application secret
* scopes: the metric type scopes specified as a JS array, ex: ["steps", "caloriesBurned", "weight"]
* baseUrl: the application base url
* accessToken: the access token for a user


## If you only have the access token, then initialize CommonSenses using the following

    CommonSenses.initializeToken(accessToken, 
                                function()
                                    {
                                    /* success callback */
                                        // set requirements
                                        // show sensor manager
                                    }, 
                                function()
                                    {
                                    /* failure callback */
                                        // handle failure
                                    });   

There are two function callbacks that a developer would use to handle success or failure of the Commonsenses initialization step.

* successCallback(required): a function callback if Commonsenses initializes successfully
* failureCallback(optional): a function callback if Commonsenses fails to initialize

Specify requirements and start the sensor manager within the success callback function.
The application requirements must specify the metric types requested along with the latency 
for each metric type in the json format.  Latencies 
allowed are: “24 hours”, “1 hour”, “1 minute”. As an example:

    var requirements = [
       {"metricType":"steps","latency":"24 hours"},
       {"metricType":"caloriesBurned","latency":"24 hours"},
       {"metricType":"weight","latency":"24 hours"}
        ];
Then, make a call to:

    CommonSenses.showSensorManager(requirements);
where,

* requirements: the specified requirements in json format
This would pop-up the sensor manager in a jQuery dialog.

Sample code:

    <script type="text/javascript" src="https://api.commonsenses.com/commonsenses-sdk/js/jquery/commonsenses-jquery.min.js"></script>
    <script type="text/javascript" src="https://api.commonsenses.com/commonsenses-sdk/js/commonsenses-sdk.js"></script>

    CommonSenses.init(appId, appSecret, scopes, redirectUrl, token, function()
           {
               var requirements = [
                   {"metricType":"steps","latency":"24 hours"},
                   {"metricType":"caloriesBurned","latency":"24 hours"},
                   {"metricType":"weight","latency":"24 hours"}
               ];
               CommonSenses.showSensorManager(requirements);
           });
OR

    <script type="text/javascript" src="https://api.commonsenses.com/commonsenses-sdk/js/jquery/commonsenses-jquery.min.js"></script>
    <script type="text/javascript" src="https://api.commonsenses.com/commonsenses-sdk/js/commonsenses-sdk.js"></script>

    CommonSenses.initializeToken(token, function()
           {
               var requirements = [
                   {"metricType":"steps","latency":"24 hours"},
                   {"metricType":"caloriesBurned","latency":"24 hours"},
                   {"metricType":"weight","latency":"24 hours"}
               ];
               CommonSenses.showSensorManager(requirements);
           });

--
--
Push Notifications


The CommonSenses server has the ability to notify your application's 
server of activity for your users. There will be a latency of several minutes between a 
new resource and the notification going out. This allows us to consolidate multiple resources
into a single message. However, each notification only cover one combination of __type__ and __operation__.
So if the user had metrics that were created and some that were updated, then your server would receive two notifications.

CommonSenses supports notifications of for the following types
of resources and operations:
### Metric
* created -- a new metric has been uploaded to the user's data
* updated -- an existing metric has been modified

### Collector
* created -- the user has registered a new collector
* selected -- the user has selected a collector to be associated with your application ( via the SensorManager )


### Notification JSON Definition:
* __type__ : the notification type: __metric__ = the notification contains metric id(s), __collector__ = the notification contains collector ids
* __operation__ : the operation that occured on the listed ids: __created__ = the id(s) were created, __updated__ = the id(s) were updated
* __ids__ : an array of CommonSenses id strings for the resources associated with this notification
* __userId__ : an id of the user associated to the resources. If your application used the Application Access token to create the user account, then the id returned is the id of the user from your system and not a CommonSenses id.
* __timeStamp__ : the date and time this notification was created

In order for your server to receive notifications, it must register one or more urls via the dev.commonsenses.com site ( TBD ) in your application's details. Once these urls are registered, we will start to send data when it is available. Our notifications are sent as POST operations. We support either a single url to which you will receive all notifications, or a different url per notification type. The choice is up to you.

We do expect your server to respond with a 200 status code upon receipt of the notification. We not currently support retry on this notifications, so non-200 status codes will be
ignored.

As the notifications contain only ids, your server will need to execute the appropriate GET call to CommonSenses to fetch the full details.

GET /metric/{metricId} or

GET /collector/{collectorId}

Recieve CommonSenses Notification
--

In this example the application added a CommonSenses user using the string 'john.q.public@myapp.com' the application's user identifier. The application registered 
the https://my-app.my-domain.com/my-app/cs/notifications url with CommonSenses.

POST /my-app/cs/notifications
> Content-Type: application/json
{
    "type": "metric",
    "operation":"create",
    "ids":["105123","105569","105990"],
    "userId":"john.q.public@myapp.com",
    "timeStamp":"2013-06-22T16:42:59Z"
}
< 200

In this example, the user was added via an OAuth 2.0 exchange and so the notification uses the CommonSenses id in the body. The application registered 
the https://my-app.my-domain.com/my-app/cs/notifications url with CommonSenses.

POST /my-app/cs/notifications
> Content-Type: application/json
{
    "type": "metric",
    "operation":"create",
    "ids":["105123","105569","105990"],
    "userId":"1010132",
    "timeStamp":"2013-06-22T16:42:59Z"
}
< 200

--
Sample API Calls


Here is a complete Python example that will work in version 2.7 of Python.  It does not work with version 3.0 of Python.

    #!/usr/bin/python
    #===================================================
    # csDemoSandbox.py
    # Example use the CommonSenses Sandbox Web Service.
    # Pre-requisite
    #    - python 2.7
    #    - urllib2
    #    - urllib
    #    - json
    #
    # calling syntax:(from cygwin)
    # python csDemoSandbox.py
    #
    #===================================================
    #===================================================
    # SET ENVIRONMENT
    # If you wish to test this with your own application
    # change the following:
    # cid - set to your application's id
    # csec - set to your application's secret
    # ruri - set to your application's redirect uri
    # csscope - set to your application's desired scopes (comma delimited list of metric types)
    #===================================================
    import urllib
    import urllib2
    import json
    
    cid="1001875581218806767393"
    csec="zzzzzz"
    ruri="https://api.commonsenses.com" 
    csscope="steps,weight,bloodPressure,bloodGlucose,height,pulseRate,met,location,speed,distanceTraveled,bmi,caloriesBurned,activityType"
    
    csuri="https://api.commonsenses.com"
    
    print("client_id: "+cid)
    print("client_secret: "+csec)
    print("redirect uri: "+ruri)
    print("CommonSenses uri: "+csuri)
    print("Scopes: "+csscope)
    
    #===================================================
    # GET AUTHORIZATION TOKEN
    # api and api-test require gui interaction with user via browser
    #===================================================
    print
    print("--------------------------------------------------------------------------------------")
    print("GET AUTHORIZATION TOKEN")
    print
    getAuthorToken_url=csuri+"/oauth/authorize?client_id="+cid+"&response_type=code&redirect_uri="+ruri+"&scope="+csscope
    print(getAuthorToken_url)
    reqAuthorToken=urllib2.Request(getAuthorToken_url)
    responseAuthorToken = urllib2.urlopen(reqAuthorToken)
    responseTextAuthorToken=responseAuthorToken.read()
    
    # Parse the authorization token from the result
    ratTuples=reqAuthorToken.redirect_dict.items()
    for items in ratTuples:
        if items[0].find('code=')>0:
            csDemoAuthToken=items[0].split('=')[1]
    
    print("    Authorization Token: "+csDemoAuthToken)
    
    #===================================================
    # GET ACCESS TOKEN
    # exchange authorizaiton token for access token
    #===================================================
    print
    print("--------------------------------------------------------------------------------------")
    print("GET ACCESS TOKEN")
    print
    getAccessToken_url=csuri+"/oauth/token?code="+csDemoAuthToken+"&client_id="+cid+"&client_secret="+csec+"&response_type=code&grant_type=authorization_code&redirect_uri="+ruri+"&scope="+csscope
    print(getAccessToken_url)
    reqAccessToken=urllib2.Request(getAccessToken_url)
    responseAccessToken = urllib2.urlopen(reqAccessToken)
    responseTextAccessTokens=eval(responseAccessToken.read())
    
    
    csDemoAccessToken=responseTextAccessTokens['access_token']
    csDemoRefreshToken=responseTextAccessTokens['refresh_token']
    print("    Access Token: "+csDemoAccessToken)
    print("    Refresh Token: "+csDemoRefreshToken)
    #===================================================
    # GET USER ID
    #===================================================
    print
    print("--------------------------------------------------------------------------------------")
    print("GET USER ID")
    print
    getUserId_url=csuri+"/user"
    print(getUserId_url)
    
    reqUserID=urllib2.Request(getUserId_url, 
                              headers={
                        "Authorization": "bearer "+csDemoAccessToken,
            			"Accept":"application/vnd.commonsenses.v1+json"})
    
    responseUserID = urllib2.urlopen(reqUserID)
    responseTextUserID=eval(responseUserID.read())					
    csDemoUserId=responseTextUserID['id']						
    print("    User Id: "+csDemoUserId)
    
    #==================================================
    # REFRESH ACCESS TOKEN
    # Exchange refresh token for new access token
    # Access tokens have a limited lifetime so it is
    # necessary to have code that catches an error when making
    # a CS call and recognizing it is time to get a
    # fresh access token with the refresh token received
    # with last access token.
    # This code does NOT demonstrate catching the error
    # but does demonstrate how to get new access and refresh
    # tokens with current refresh token
    # On sandbox the lifetime of an access token is very long (24 hours or more)
    #==================================================
    print
    print("--------------------------------------------------------------------------------------")
    print("REFRESH ACCESS TOKEN")
    print
    refreshAccessToken_url= csuri+"/oauth/token?refresh_token="+csDemoRefreshToken+"&client_id="+cid+"&client_secret="+csec+"&response_type=code&grant_type=refresh_token&redirect_uri="+ruri+"&scope="+csscope
    print(refreshAccessToken_url)
    reqRefreshAccessToken=urllib2.Request(refreshAccessToken_url)
    responseRefreshAccessToken = urllib2.urlopen(reqRefreshAccessToken)
    responseTextRefreshAccessTokens=eval(responseRefreshAccessToken.read())
    
    	
    # Parse the new access token and refresh token from result
    csDemoAccessToken=responseTextRefreshAccessTokens['access_token']
    csDemoRefreshToken=responseTextRefreshAccessTokens['refresh_token']
    print("    Access Token: "+csDemoAccessToken)
    print("    Refresh Token: "+csDemoRefreshToken)
    
    #===================================================
    # POST USER Metrics
    # Since sandbox does not have any real users with real data
    # we need to post some data into our user's account.
    # This is what a gateway device will normally do
    # APPLICATIONS DO NOT NORMALY USE THIS
    # This is here to simulate a sensor getting data
    # and putting it into a users account.
    # The data posted is defined in the file postData1.json
    #===================================================
    print
    print("--------------------------------------------------------------------------------------")
    print("POST METRICS (Steps)")
    
    fp=open('postData1.json','r')
    jsonData=json.load(fp)
    fp.close()
    
    
    postMetrics_url=csuri+"/user/"+csDemoUserId+"/metric"
    print(postMetrics_url)
    print(json.dumps(jsonData, indent=4))
    outgoingData=json.dumps(jsonData)
    reqPostMetrics=urllib2.Request(postMetrics_url,
    			headers={"Authorization":"bearer "+csDemoAccessToken,
    					"Content-type":"application/vnd.commonsenses.v1+json"})
    reqPostMetrics.add_data(outgoingData)
    
    responsePostMetrics = urllib2.urlopen(reqPostMetrics)
    postMetrics=responsePostMetrics.read()
    
    
    #===================================================
    # GET USER Metrics (Steps)
    #===================================================
    print
    print("--------------------------------------------------------------------------------------")
    print("GET USER METRICS (Steps)")
    print
    
    userSteps_url=csuri+"/user/"+csDemoUserId+"/metric-collection?types=steps"
    print(userSteps_url)
    reqUserSteps=urllib2.Request(userSteps_url,
    			headers={"Authorization":"bearer "+csDemoAccessToken,
    					"Content-type":"application/vnd.commonsenses.v1+json",
    					"Accept":"application/vnd.commonsenses.v1+json",
    					"Accept-Encoding":"application/vnd.commonsenses.v1+json"})
    
    responseUserSteps = urllib2.urlopen(reqUserSteps)
    userSteps=json.loads(responseUserSteps.read())
    
    print json.dumps(userSteps,indent=4)
    
    print
    print("Note: Examine the collector HREF as follows:")
    print("userSteps['metric'][0]['collector']['href']")
    print
    
    
    #===================================================
    # POST Collector To A User
    #===================================================
    print
    print("--------------------------------------------------------------------------------------")
    print("POST Collector")
    
    fp=open('postCollector1.json','r')
    jsonData=json.load(fp)
    fp.close()
    
    
    postCollector_url=csuri+"/user/"+csDemoUserId+"/collector?request_uri="+ruri
    print(postCollector_url)
    print(json.dumps(jsonData, indent=4))
    outgoingData=json.dumps(jsonData)
    reqPostCollector=urllib2.Request(postCollector_url,
    			headers={"Authorization":"bearer "+csDemoAccessToken,
    					"Content-type":"application/vnd.commonsenses.v1+json"})
    reqPostCollector.add_data(outgoingData)
    
    responsePostCollector = urllib2.urlopen(reqPostCollector)
    postCollector=responsePostCollector.read()
    
    
    
    #===================================================
    # GET Collectors
    #===================================================
    print
    print("--------------------------------------------------------------------------------------")
    print("GET USER Collectors")
    print
    
    collectors_url=csuri+"/user/"+csDemoUserId+"/collector-collection"
    print(collectors_url)
    reqCollectors=urllib2.Request(collectors_url,
    			headers={"Authorization":"bearer "+csDemoAccessToken,
    					"Content-type":"application/vnd.commonsenses.v1+json",
    					"Accept":"application/vnd.commonsenses.v1+json",
    					"Accept-Encoding":"application/vnd.commonsenses.v1+json"})
    
    responseCollectors = urllib2.urlopen(reqCollectors)
    collectors=json.loads(responseCollectors.read())
    
    print json.dumps(collectors,indent=4)

    
There are two support files for the Sandbox Python example.  

postData1.json

    {
    "data" : [ {
                "endTime" : "2013-04-01T11:45:24.127-04:00",
                "startTime" : "2013-04-01T11:45:24.126-04:00",
                "value" : [ "1305" ]
               } ],
    "metaData" : [ {
                     "com_Elbrys_MetadataExample1" : "34"
                   },
                   {
                    "org_Example_MetaDataExample2" : "Example Metadata"
                    } ],
    "metricType" : "steps",
    "profileAccumulator" : "sum",
    "profileName" : "steps",
    "profileUnits" : "{step}",
    "ver" : "1"
    }
postCollector1.json

    {
    "ver":"1",
    "connectionType":"internal",
    "deviceManufacturer":"fitlinxx"
    }
--

